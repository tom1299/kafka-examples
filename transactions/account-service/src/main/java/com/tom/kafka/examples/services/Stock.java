/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.tom.kafka.examples.services;

import com.tom.kafka.examples.KafkaUtils;
import com.tom.kafka.examples.model.StockEvent;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.kstream.*;
import org.apache.kafka.streams.state.Stores;

@Slf4j
public class Stock extends AbstractKafkaApp {

    private Long aggregate(String stock, StockEvent stockEvent,
                           Long currentQuantity) {
        log.info("Processing stock event {} for stock {}", stockEvent.getTransactionId(), stock);
        long quantity = 0L;
        if (stockEvent.getType() == StockEvent.Type.ADDITION) {
            quantity = handleAddition(stockEvent, currentQuantity);
        }
        else if (stockEvent.getType() == StockEvent.Type.REMOVAL) {
            quantity = handleRemoval(stockEvent, currentQuantity);
        }
        return quantity;
    }

    private long handleRemoval(StockEvent stockEvent, Long currentQuantity) {
        long newQuantity = currentQuantity;
        if (currentQuantity - stockEvent.getAmount() < 0) {
            log.info("Insufficient stock of {} for stock {} to remove amount {}", currentQuantity, stockEvent.getStock(), stockEvent.getAmount());
            stockEvent.setStatus(StockEvent.Status.REJECTED);
        }
        else {
            newQuantity = currentQuantity - stockEvent.getAmount();
            stockEvent.setStatus(StockEvent.Status.FULFILLED);
            log.info("Removed {} from stock {}. New quantity is {}", stockEvent.getAmount(), stockEvent.getStock(), newQuantity);
        }
        return newQuantity;
    }

    private long handleAddition(StockEvent stockEvent, Long currentQuantity) {
        stockEvent.setStatus(StockEvent.Status.FULFILLED);
        long newQuantity = currentQuantity + stockEvent.getAmount();
        log.info("Added {} to to stock {}. New quantity is {}", stockEvent.getAmount(), stockEvent.getStock(), newQuantity);
        return newQuantity;
    }

    protected void addTopology(StreamsBuilder builder) {
        Initializer<Long> initializer = () -> 0L;

        KStream<String, StockEvent> stream = builder.stream("stock-transactions", Consumed.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(StockEvent.class)));

        stream.groupByKey().aggregate(initializer, this::aggregate, Materialized
                .<String, Long>as(Stores.inMemoryKeyValueStore("stocks")).withCachingDisabled()
                .withKeySerde(Serdes.String()).withValueSerde(Serdes.Long()));
        stream.selectKey((key, stockEvent) -> stockEvent.getTransactionId()).to("processed-stock-transactions", Produced.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(StockEvent.class)));
    }

    public static void main(String[] args) {
        Stock app = new Stock();
        app.run();
    }
}
