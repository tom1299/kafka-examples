/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.tom.kafka.examples.services;

import com.tom.kafka.examples.KafkaUtils;
import com.tom.kafka.examples.model.AccountEvent;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.*;
import org.apache.kafka.streams.state.Stores;

@Slf4j
public class Account extends AbstractKafkaApp {

    private Long aggregate(String account, AccountEvent accountEvent,
                           Long currentBalance) {
        log.info("Processing account event {} for user {}", accountEvent.getTransactionId(), account);
        long newBalance = 0L;
        AccountEvent.Status oldStatus = accountEvent.getStatus();
        if (accountEvent.getType() == AccountEvent.Type.DEPOSIT) {
            newBalance = handleDeposit(accountEvent, currentBalance);
        } else if (accountEvent.getType() == AccountEvent.Type.WITHDRAW) {
            newBalance = handleWithdraw(accountEvent, currentBalance);
        }
        if (oldStatus == AccountEvent.Status.COMPENSATION) {
            accountEvent.setStatus(AccountEvent.Status.COMPENSATION);
        }
        return newBalance;
    }

    private long handleWithdraw(AccountEvent accountEvent, Long currentBalance) {
        long newBalance = currentBalance;
        if (currentBalance - accountEvent.getAmount() < 0) {
            log.info("Insufficient balance of {} on user account {} to withdraw amount {}", currentBalance, accountEvent.getUserId(), accountEvent.getAmount());
            accountEvent.setStatus(AccountEvent.Status.REJECTED);
        } else {
            newBalance = currentBalance - accountEvent.getAmount();
            accountEvent.setStatus(AccountEvent.Status.FULFILLED);
            log.info("Withdrew {} from user account {}. New balance is {}", accountEvent.getAmount(), accountEvent.getUserId(), newBalance);
        }
        return newBalance;
    }

    private long handleDeposit(AccountEvent accountEvent, Long currentBalance) {
        accountEvent.setStatus(AccountEvent.Status.FULFILLED);
        long newBalance = currentBalance + accountEvent.getAmount();
        log.info("Added {} to user account {}. New balance is {}", accountEvent.getAmount(), accountEvent.getUserId(), newBalance);
        return newBalance;
    }

    protected Topology addTopology() {
        StreamsBuilder builder = new StreamsBuilder();
        KStream<String, AccountEvent> stream = builder.stream("account-transactions", Consumed.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(AccountEvent.class)));

        stream.groupByKey().aggregate(() -> 0L, this::aggregate, Materialized
                .<String, Long>as(Stores.inMemoryKeyValueStore("accounts")).withCachingDisabled()
                .withKeySerde(Serdes.String()).withValueSerde(Serdes.Long()));

        stream.filter(((key, accountEvent) -> accountEvent.getStatus() != AccountEvent.Status.COMPENSATION))
                .selectKey((key, accountEvent) -> accountEvent.getTransactionId())
                .to("processed-account-transactions", Produced.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(AccountEvent.class)));

        return builder.build();
    }

    public static void main(String[] args) {
        Account app = new Account();
        app.run();
    }
}
