/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.tom.kafka.examples.services;

import com.tom.kafka.examples.KafkaUtils;
import com.tom.kafka.examples.model.OrderEvent;
import com.tom.kafka.examples.model.PriceEvent;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.Consumed;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.Produced;
import org.apache.kafka.streams.processor.Processor;
import org.apache.kafka.streams.processor.ProcessorContext;
import org.apache.kafka.streams.state.KeyValueStore;
import org.apache.kafka.streams.state.StoreBuilder;
import org.apache.kafka.streams.state.Stores;

@Slf4j
public class Prices extends AbstractKafkaApp {

    public static final String PRICES_STATE_STORE_NAME = "prices";

    private static Processor<String, PriceEvent> updatePrices() {
        return new Processor<String, PriceEvent>() {

            KeyValueStore<String, Long> prices;

            @SuppressWarnings("unchecked")
            @Override
            public void init(ProcessorContext context) {
                this.prices = (KeyValueStore<String, Long>) context.getStateStore(PRICES_STATE_STORE_NAME);
            }

            @Override
            public void process(String key, PriceEvent priceEvent) {
                log.info("Processing price event for stock {}", priceEvent.getStock());
                Long currentPrice = prices.get(priceEvent.getStock());
                log.info("Current price for for stock {} is {}", priceEvent.getStock(), currentPrice);
                prices.put(priceEvent.getStock(), priceEvent.getNewPrice());
                log.info("New price for for stock {} set to {}", priceEvent.getStock(), priceEvent.getNewPrice());
            }

            @Override
            public void close() {
                // No close necessary
            }
        };
    }

    protected Topology addTopology() {
        StreamsBuilder builder = new StreamsBuilder();
        KStream<String, PriceEvent> priceEventStream = builder.stream("price-updates", Consumed.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(PriceEvent.class)));

        StoreBuilder<KeyValueStore<String, Long>> priceStoreSupplier = Stores.keyValueStoreBuilder(
                Stores.persistentKeyValueStore(PRICES_STATE_STORE_NAME),
                Serdes.String(),
                Serdes.Long())
                .withCachingEnabled();

        builder.addStateStore(priceStoreSupplier);

        priceEventStream.process(Prices::updatePrices, PRICES_STATE_STORE_NAME);

        priceEventStream.selectKey((key, accountEvent) -> accountEvent.getId()).to("processed-price-updates", Produced.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(PriceEvent.class)));

        KStream<String, OrderEvent> orderEventStream = builder.stream("incoming-orders", Consumed.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(OrderEvent.class)));

        orderEventStream.process(() -> new Processor<String, OrderEvent>() {

            KeyValueStore<String, Long> prices;

            @Override
            @SuppressWarnings("unchecked")
            public void init(ProcessorContext context) {
                this.prices = (KeyValueStore<String, Long>) context.getStateStore(PRICES_STATE_STORE_NAME);
            }

            @Override
            public void process(String transactionId, OrderEvent orderEvent) {
                log.info("Processing order event {} for stock {}", transactionId, orderEvent.getStock());
                Long currentPrice = prices.get(orderEvent.getStock());
                log.info("Current price for for stock {} is {}", orderEvent.getStock(), currentPrice);
                long price = orderEvent.getAmount() * (currentPrice == null ? 0 : currentPrice);
                log.info("Price for for stock {} and amount {} is {}", orderEvent.getStock(), orderEvent.getAmount(), price);
                orderEvent.setPrice(price);
            }

            @Override
            public void close() {
                // No close necessary
            }
        }, PRICES_STATE_STORE_NAME);

        orderEventStream.to("priced-orders", Produced.with(KafkaUtils.keySerde,
                KafkaUtils.getSerde(OrderEvent.class)));

        return builder.build();
    }

    public static void main(String[] args) {
        Prices app = new Prices();
        app.run();
    }
}
